package itAcademy.ORM.transaction;

import itAcademy.ORM.annotations.Id;
import itAcademy.ORM.mapping.Column;
import itAcademy.ORM.mapping.Table;
import itAcademy.ORM.reflection.Reflection;
import itAcademy.ORM.reflection.ReflectionAPI;
import itAcademy.ORM.reflection.ReflectionException;

import java.io.IOException;
import java.io.Reader;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

public class BaseTransaction implements Transaction {

    protected Connection connection;
    private Class idClass = Id.class;

    BaseTransaction(Connection connection) {
        this.connection = connection;
    }

    BaseTransaction(Connection connection, boolean autoCommit) {
        this.connection = connection;
        try {
            if (connection.getAutoCommit() != autoCommit) {
                connection.setAutoCommit(autoCommit);
            }
        } catch (SQLException e) {
            throw new TransactionException("Set auto commit error: " + e.getMessage(), e);
        }
    }

    @Override
    public Connection open() throws TransactionException {
        return connection;
    }

    @Override
    public void commit() throws TransactionException {
        try {
            if (!connection.getAutoCommit()) {
                connection.commit();
            }
        } catch (SQLException e) {
            new TransactionException("Commit error: " + e.getMessage(), e);
        }
    }

    @Override
    public void rollback() throws TransactionException {
        try {
            if (!connection.getAutoCommit()) {
                connection.rollback();
            }
        } catch (SQLException e) {
            throw new TransactionException("Rollback error: " + e.getMessage(), e);
        }
    }

    @Override
    public void close() throws TransactionException {
        try {
            if (!connection.getAutoCommit()) {
                connection.setAutoCommit(true);
            }
            if (connection != null && !connection.isClosed())
                connection.close();
        } catch (SQLException e) {
            throw new TransactionException("Error closing SQL connection: " + e.getMessage(), e);
        }
    }


    public Object update(Object obj) throws IllegalAccessException, SQLException {
        Map<String, Object> fields = new LinkedHashMap<>();
        String pkField = "";
        Object pkFieldValue = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (!java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                if (field.isAnnotationPresent(Id.class)) {
                    pkField = field.getAnnotation(Id.class).fieldName();
                    field.setAccessible(true);
                    pkFieldValue = field.get(obj);
                } else if (field.isAnnotationPresent(itAcademy.ORM.annotations.Column.class)) {
                    field.setAccessible(true);
                    fields.put(field.getAnnotation(itAcademy.ORM.annotations.Column.class).fieldName(), field.get(obj));
                }

            }
        }
        Set<String> fieldsSet = fields.keySet();
        String names = fieldsSet.stream().collect(Collectors.joining("=?,", "", "=?"));
        String tableName = "";
        for (Table t : ReflectionAPI.getTables()) {
            if (t.getEntity().getTypeName().equals(obj.getClass().getTypeName()))
                tableName = t.getTableName();
        }
        String sql = "update  " + tableName + " set " + names + " where " + pkField + "=?";
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                Object value = fields.get(it.next());
                preparedStatement.setObject(i, value);
                ++i;
            }
            preparedStatement.setObject(i, pkFieldValue);
            preparedStatement.executeUpdate();
        }
        return obj;
    }

    @Override
    public Object insert(Object obj) throws IllegalAccessException, SQLException, ReflectionException {
        LinkedHashMap<String, Object> fields = new LinkedHashMap<>();
        boolean autoGenerated = false;
        String autoGeneratedField = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                boolean autoIncremental;
                if (Reflection.getFieldValue(obj, field.getName()) == null) {
                    autoIncremental = field.getAnnotation(Id.class).autoIncremental();
                } else {
                    autoIncremental = false;
                }
                if (autoIncremental) {
                    autoGenerated = true;
                    autoGeneratedField = field.getName();
                } else
                    field.setAccessible(true);
                fields.put(field.getDeclaredAnnotation(Id.class).fieldName(), field.get(obj));
            }
            if (field.isAnnotationPresent(itAcademy.ORM.annotations.Column.class)) {
                field.setAccessible(true);
                fields.put(field.getAnnotation(itAcademy.ORM.annotations.Column.class).fieldName(), field.get(obj));
            }
        }
        Set<String> fieldsSet = fields.keySet();
        String names = String.join(",", fieldsSet);
        String values = fieldsSet.stream().map(it -> "?").collect(Collectors.joining(","));

        String tableName = "";
        for (Table t : ReflectionAPI.getTables()) {
            if (t.getEntity().getTypeName().equals(obj.getClass().getTypeName()))
                tableName = t.getTableName();
        }
        String sql = "insert into " + tableName + "(" + names + ") values (" + values + ")";
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                preparedStatement.setObject(i, fields.get(it.next()));
                ++i;
            }
            preparedStatement.executeUpdate();
            if (autoGenerated) {
                ResultSet tableKeys = preparedStatement.getGeneratedKeys();
                tableKeys.next();
                Object autoGeneratedID = tableKeys.getObject(1);
                Reflection.setField(obj, autoGeneratedField, autoGeneratedID);
            }
        }
        return obj;
    }

    public ArrayList<Object> findBy(String where, Class classObject, Object... params) throws SQLException, IllegalAccessException, InstantiationException, ReflectionException, IOException {
        ArrayList<Object> ret = new ArrayList<>();
        StringBuilder names = new StringBuilder();
        Table t = null;
        for (Table table : ReflectionAPI.getTables()) {
            if (table.getEntity().getTypeName().endsWith(classObject.getSimpleName()))
                t = table;
        }
        for (Column column : t.getColumns()) {
            if (names.length() > 0) {
                names.append(",");
            }
            names.append(column.getDbName());

        }
        String sql;
        if (where == null) {
            sql = "select " + names + " from  " + t.getTableName();
        } else {
            sql = "select " + names + " from  " + t.getTableName() + " where " + where;
        }
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }
            ResultSet r = preparedStatement.executeQuery();
            while (r.next()) {
                Object row = classObject.newInstance();
                for (Column column : t.getColumns()) {
                    Object value = r.getObject(column.getDbName());
                    if (value instanceof Clob) {
                        Reader reader = ((Clob) value).getCharacterStream();
                        int intValueOfChar;
                        StringBuilder targetString = new StringBuilder();
                        while ((intValueOfChar = reader.read()) != -1) {
                            targetString.append((char) intValueOfChar);
                        }
                        reader.close();
                        Reflection.setField(row, column.getJavaName(), targetString.toString());
                    } else {
                        Reflection.setField(row, column.getJavaName(), value);
                    }
                }
                ret.add(row);
            }
            r.close();
        }
        return ret;
    }

    public Object findOne(Class className, Object primaryKey) throws SQLException, ReflectionException, InstantiationException, IllegalAccessException, IOException {
        String pkName;
        Table t = null;
        for (Table table : ReflectionAPI.getTables()) {
            if (table.getEntity().getTypeName().equals(className.getTypeName()))
                t = table;
        }
        for (Field field : className.getDeclaredFields()) {
            for (Annotation annotation : field.getDeclaredAnnotations())
                if (annotation.annotationType().equals(idClass)) {
                    pkName = t.getMapping().get(field.getName());
                    if (field.getType().getName().equals("java.lang.Long") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Long.valueOf((String) primaryKey));
                        return ret.size() > 0 ? ret.get(0) : null;
                    }
                    if (field.getType().getName().equals("java.lang.Double") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Double.valueOf((String) primaryKey));
                        return ret.size() > 0 ? ret.get(0) : null;

                    }
                    if (field.getType().getName().equals("java.lang.Float") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Float.valueOf((String) primaryKey));
                        return ret.size() > 0 ? ret.get(0) : null;
                    }
                    if (field.getType().getName().equals("java.lang.Integer") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Integer.valueOf((String) primaryKey));
                        return ret.size() > 0 ? ret.get(0) : null;

                    }
                    ArrayList<Object> ret = findBy(pkName + "=?", className, primaryKey);
                    return ret.size() > 0 ? ret.get(0) : null;

                }
        }
        throw new ReflectionException("Cant find PK attribute");
    }

    public int deleteBy(String where, Class classObject, Object... params) throws SQLException {
        Table t = null;
        for (Table table : ReflectionAPI.getTables()) {
            if (table.getEntity().getTypeName().endsWith(classObject.getTypeName()))
                t = table;
        }
        String sql = "delete from " + t.getTableName() + " where " + where;
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }
            return preparedStatement.executeUpdate();
        }
    }

    public int delete(Object obj) throws IllegalAccessException, SQLException {
        String pkName = null;
        Object pkValue = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                pkName = field.getAnnotation(Id.class).fieldName();
                field.setAccessible(true);
                pkValue = field.get(obj);
            }
        }
        return deleteBy(pkName + "=?", obj.getClass(), pkValue);
    }

    public ArrayList<Object> findAll(Class classObject) throws SQLException, ReflectionException, InstantiationException, IllegalAccessException, IOException {
        return findBy(null, classObject);
    }

    public ArrayList<HashMap<String, Object>> selectQuery(String sqlQuery, Object... params) throws SQLException {
        try (PreparedStatement preparedStatement = connection.prepareStatement(sqlQuery)) {
            ArrayList<HashMap<String, Object>> ret = new ArrayList<HashMap<String, Object>>();
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }
            ResultSet r = preparedStatement.executeQuery();
            ResultSetMetaData rsmd = r.getMetaData();
            while (r.next()) {
                HashMap<String, Object> row = new HashMap<>();
                for (i = 1; i <= rsmd.getColumnCount(); ++i) {
                    String name = rsmd.getColumnName(i);
                    Object value = r.getObject(name);
                    row.put(name, value);
                }
                ret.add(row);
            }
            return ret;
        }
    }
}
