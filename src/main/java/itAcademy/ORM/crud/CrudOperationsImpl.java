package itAcademy.ORM.crud;

import itAcademy.ORM.annotations.Id;
import itAcademy.ORM.connection.connectionpool.DBCPDataSourceFactory;
import itAcademy.ORM.connection.support.DaoSupport;
import itAcademy.ORM.mapping.Column;
import itAcademy.ORM.mapping.Table;
import itAcademy.ORM.reflection.ReflectionAPI;
import itAcademy.ORM.reflection.ReflectionException;

import java.io.IOException;
import java.io.Reader;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

import static itAcademy.ORM.crud.SQLCommands.*;

public class CrudOperationsImpl implements CrudOperations {

    private DBCPDataSourceFactory dataSource = new DBCPDataSourceFactory();
    private Connection connection = DaoSupport.getConnection(dataSource.getDataSource());


    @Override
    public Object update(Object obj) {
        Map<String, Object> fields = new LinkedHashMap<>();
        HelperUpdate helperUpdate = null;
        try {
            helperUpdate = new HelperUpdate(obj, fields, "", null).invoke();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        String pkField = helperUpdate.getPkField();
        Object pkFieldValue = helperUpdate.getPkFieldValue();
        Set<String> fieldsSet = fields.keySet();
        String names = fieldsSet.stream().collect(Collectors.joining("=?,", "", "=?"));
        String tableName = getTableName(obj);
        String sql = UPDATE + tableName + SET + names + WHERE + pkField + "=?";
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                Object value = fields.get(it.next());
                preparedStatement.setObject(i++, value);
            }
            preparedStatement.setObject(i, pkFieldValue);
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return obj;
    }


    @Override
    public Object insert(Object obj) {
        LinkedHashMap<String, Object> fields = new LinkedHashMap<>();
        HelperInsert helperInsert = null;
        try {
            helperInsert = new HelperInsert(obj, fields, false, null).invoke();
        } catch (IllegalAccessException | ReflectionException e) {
            e.printStackTrace();
        }
        boolean autoGenerated = helperInsert.isAutoGenerated();
        String autoGeneratedField = helperInsert.getAutoGeneratedField();
        Set<String> fieldsSet = fields.keySet();
        String names = String.join(COMMA, fieldsSet);
        String values = fieldsSet.stream().map(it -> QUESTION_MARK).collect(Collectors.joining(COMMA));
        String tableName = getTableName(obj);
        String sql = INSERT + INTO + tableName + LEFT_BRACKET + names + RIGHT_BRACKET + VALUES + LEFT_BRACKET + values + RIGHT_BRACKET + ";";
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                preparedStatement.setObject(i++, fields.get(it.next()));
            }
            preparedStatement.executeUpdate();
            if (autoGenerated) {
                ResultSet tableKeys = preparedStatement.getGeneratedKeys();
                tableKeys.next();
                Object autoGeneratedID = tableKeys.getObject(1);
                ReflectionAPI.setField(obj, autoGeneratedField, autoGeneratedID);
            }
        } catch (IllegalAccessException | SQLException | ReflectionException e) {
            e.printStackTrace();
        }
        return obj;
    }

    public ArrayList<Object> findBy(String where, Class classObject, Object... params) {
        ArrayList<Object> ret = new ArrayList<>();
        Table t = getTables(classObject);
        String names = getColumnsName(t);
        String sql = SELECT + names + FROM + t.getTableName();
        if (where != null) {
            sql += WHERE + where;
        }
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i++, param);
            }
            ResultSet r = preparedStatement.executeQuery();
            while (r.next()) {
                Object row = classObject.newInstance();
                for (Column column : t.getColumns()) {
                    Object value = r.getObject(column.getDbName());
                    setFields(row, column, value);
                }
                ret.add(row);
            }
            r.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ret;
    }


    public Object findOne(Class className, Object primaryKey) throws ReflectionException {
        String pkName;
        Table t = getTables(className);
        for (Field field : className.getDeclaredFields()) {
            for (Annotation annotation : field.getDeclaredAnnotations())
                if (annotation.annotationType().equals(Id.class)) {
                    pkName = t.getMapping().get(field.getName());
                    try {
                        return getObject(className, primaryKey, pkName, field);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
        }
        throw new ReflectionException("Cant find PK attribute");
    }


    public int deleteBy(String where, Class classObject, Object... params) {
        Table t = getTables(classObject);
        String sql = DELETE + FROM + t.getTableName() + WHERE + where;
        try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i++, param);
            }
            return preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public int delete(Object obj) {
        String pkName = null;
        Object pkValue = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                pkName = field.getAnnotation(Id.class).fieldName();
                field.setAccessible(true);
                try {
                    pkValue = field.get(obj);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
        return deleteBy(pkName + INTERMEDIATE_VALUE_MY_SQL, obj.getClass(), pkValue);
    }

    public ArrayList<Object> findAll(Class classObject) {
        return findBy(null, classObject);
    }


    private Table getTables(Class className) {
        Table t = null;
        for (Table table : ReflectionAPI.getTables()) {
            if (table.getEntity().getTypeName().equals(className.getTypeName()))
                t = table;
        }
        return t;
    }

    private String getTableName(Object obj) {
        String tableName = EMPTY_STRING;
        for (Table t : ReflectionAPI.getTables()) {
            if (t.getEntity().getTypeName().equals(obj.getClass().getTypeName()))
                tableName = t.getTableName();
        }
        return tableName;
    }

    private void setFields(Object row, Column column, Object value) {
        try {
            if (value instanceof Clob) {
                Reader reader = ((Clob) value).getCharacterStream();
                int intValueOfChar;
                StringBuilder targetString = new StringBuilder();
                while ((intValueOfChar = reader.read()) != -1) {
                    targetString.append((char) intValueOfChar);
                }
                reader.close();
                ReflectionAPI.setField(row, column.getJavaName(), targetString.toString());
            } else {
                ReflectionAPI.setField(row, column.getJavaName(), value);
            }
        } catch (IllegalAccessException | SQLException | IOException | ReflectionException e) {
            e.printStackTrace();
        }
    }

    private String getColumnsName(Table t) {
        StringBuilder names = new StringBuilder();
        for (Column column : t.getColumns()) {
            if (names.length() > 0) {
                names.append(COMMA);
            }
            names.append(column.getDbName());
        }
        return names.toString();
    }

    private Object getObject(Class className, Object primaryKey, String pkName, Field field) throws Exception {
        ArrayList<Object> ret;
        switch (field.getType().getName()) {
            case ("java.lang.Long"):
                ret = findBy(pkName + INTERMEDIATE_VALUE_MY_SQL, className, Long.valueOf((String) primaryKey));
                return ret.size() > 0 ? ret.get(0) : null;
            case ("java.lang.Double"):
                ret = findBy(pkName + INTERMEDIATE_VALUE_MY_SQL, className, Double.valueOf((String) primaryKey));
                return ret.size() > 0 ? ret.get(0) : null;
            case ("java.lang.Float"):
                ret = findBy(pkName + INTERMEDIATE_VALUE_MY_SQL, className, Float.valueOf((String) primaryKey));
                return ret.size() > 0 ? ret.get(0) : null;
            case ("java.lang.Integer"):
                ret = findBy(pkName + INTERMEDIATE_VALUE_MY_SQL, className, Integer.valueOf((String) primaryKey));
                return ret.size() > 0 ? ret.get(0) : null;
            default:
                ret = findBy(pkName + INTERMEDIATE_VALUE_MY_SQL, className, primaryKey);
                return ret.size() > 0 ? ret.get(0) : null;
        }
    }

    private static final class HelperInsert {
        private Object obj;
        private LinkedHashMap<String, Object> fields;
        private boolean autoGenerated;
        private String autoGeneratedField;

        HelperInsert(Object obj, LinkedHashMap<String, Object> fields, boolean autoGenerated, String autoGeneratedField) {
            this.obj = obj;
            this.fields = fields;
            this.autoGenerated = autoGenerated;
            this.autoGeneratedField = autoGeneratedField;
        }

        boolean isAutoGenerated() {
            return autoGenerated;
        }

        String getAutoGeneratedField() {
            return autoGeneratedField;
        }

        HelperInsert invoke() throws IllegalAccessException, ReflectionException {
            for (Field field : obj.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                if (field.isAnnotationPresent(Id.class)) {
                    boolean autoIncremental = false;
                    if (ReflectionAPI.getFieldValue(obj, field.getName()) == null) {
                        autoIncremental = field.getAnnotation(Id.class).autoIncremental();
                    }
                    if (autoIncremental) {
                        autoGenerated = true;
                        autoGeneratedField = field.getName();
                    }
                    fields.put(field.getDeclaredAnnotation(Id.class).fieldName(), field.get(obj));
                }
                if (field.isAnnotationPresent(itAcademy.ORM.annotations.Column.class)) {
                    fields.put(field.getAnnotation(itAcademy.ORM.annotations.Column.class).fieldName(), field.get(obj));
                }
            }
            return this;
        }
    }

    private static final class HelperUpdate {
        private Object obj;
        private Map<String, Object> fields;
        private String pkField;
        private Object pkFieldValue;

        HelperUpdate(Object obj, Map<String, Object> fields, String pkField, Object pkFieldValue) {
            this.obj = obj;
            this.fields = fields;
            this.pkField = pkField;
            this.pkFieldValue = pkFieldValue;
        }

        String getPkField() {
            return pkField;
        }

        Object getPkFieldValue() {
            return pkFieldValue;
        }

        HelperUpdate invoke() throws IllegalAccessException {
            for (Field field : obj.getClass().getDeclaredFields()) {
                if (!java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                    if (field.isAnnotationPresent(Id.class)) {
                        pkField = field.getAnnotation(Id.class).fieldName();
                        field.setAccessible(true);
                        pkFieldValue = field.get(obj);
                    } else if (field.isAnnotationPresent(itAcademy.ORM.annotations.Column.class)) {
                        field.setAccessible(true);
                        fields.put(field.getAnnotation(itAcademy.ORM.annotations.Column.class).fieldName(), field.get(obj));
                    }
                }
            }
            return this;
        }
    }
}
